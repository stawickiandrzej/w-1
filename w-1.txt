Warsztaty Python – zajecia nr 1
Plan:
I.	Dystrybucje Pythona
II.	Tryby pracy (interaktywny i wsadowy)
W konsoli wykonaj nastêpuj¹ce dzia³ania oraz przyjrzyj siê odpowiedziom komputera.
1.	Dodawanie i odejmowanie – sprawdŸ dzia³anie poni¿szego kodu
>>> 1 + 2
3
>>> 1 + 3.5
4.5
>>> -1 + 2.5
1.5
>>> 100 – 45
55
>>> -1.1 + 5
3.9

2.	Mno¿enie – sprawdŸ dzia³anie poni¿szego kodu
>>> 3 * 2
6
>>> 3.5 * 1.5
5.25

3.	Dzielenie – sprawdŸ dzia³anie poni¿szego kodu
>>> 3 / 2
1.5
>>> 4 / 2
2.0

4.	Dzielenie bez czêœci dziesiêtnej w wyniku – sprawdŸ dzia³anie poni¿szego kodu
>>> 3 // 2
1
>>> -3 // 2
-2

5.	Dzielnie modulo – sprawdŸ dzia³anie poni¿szego kodu
>>> 9 % 2
1

6.	Potêgowanie – sprawdŸ dzia³anie poni¿szego kodu
>>> 2 ** 2
4
>>> 2 ** 10
1024
>>> 1 ** 10
1
>>> 8 ** (1/3)
2.0

7.	Kolejnoœæ wykonywania dzia³añ – sprawdŸ dzia³anie poni¿szego kodu
>>> 5 + 5 * 5
30
>>> (5 + 5) * 5
50

8.	Przypisywanie zmiennych – sprawdŸ dzia³anie poni¿szego kodu
>>> a = 3
>>> a + 1
4
>>> a = 5
>>> a + 1
6

9.	Typy danych – sprawdŸ dzia³anie poni¿szego kodu
>>> type(3)
<class 'int'>
>>> type(3.5)
<class 'float'>
>>> type(3.0)
<class 'float'>


10.	Rzutowanie (konwersja) typów – sprawdŸ dzia³anie poni¿szego kodu

>>> int(3.8)
3
>>> int(3.0)
3
>>> float(3)
3.0

11.	U³amki (oraz importowanie bibliotek) – sprawdŸ dzia³anie poni¿szego kodu

>>> from fractions import Fraction
>>> f = Fraction(3, 4)
>>> f
Fraction(3, 4)
>>> Fraction(3, 4) + 1 + 1.5
3.25
Fraction(3, 4) + 1 + Fraction(1/4)
Fraction(2, 1)

12.	Liczby zespolone – sprawdŸ dzia³anie poni¿szego kodu

>>> a = 2 + 3j
>>> type(a)
<class 'complex'>

>>> a = complex(2, 3)
>>> a
(2 + 3j)

>>> b = 3 + 3j
>>> a + b
(5 + 6j)
>>> a - b
(-1 + 0j)

>>> a * b
(-3 + 15j)
>>> a / b
(0.8333333333333334 + 0.16666666666666666j)

>>> z = 2 + 3j
>>> z.real
2.0
>>> z.imag
3.0

>>> z.conjugate()
(2 - 3j)

>>> (z.real ** 2 + z.imag ** 2) ** 0.5
3.605551275463989

>>> abs(z)
3.605551275463989

13.	Przyjmowanie danych od u¿ytkownika – sprawdŸ dzia³anie poni¿szego kodu

>>> a = input()
1

>>> a
'1'

>>> s1 = 'a string'
>>> s2 = "a string"

>>> a = '1'
>>> int(a) + 1
2
>>> float(a) + 1
2.0

14.	Wyj¹tki - wprowadŸ poni¿sze instrukcje i przeanalizuj odpowiedzi interpretera

>>> int('2.0')
Traceback (most recent call last):
Working with Numbers 9
File "<pyshell#26>", line 1, in <module>
int('2.0')
ValueError: invalid literal for int() with base 10: '2.0'

>>> a = float(input())
3/4
Traceback (most recent call last):
File "<pyshell#25>", line 1, in <module>
a=float(input())
ValueError: could not convert string to float: '3/4'

15.	Obs³uga wyj¹tków – sprawdŸ dzia³anie poni¿szego kodu
Wczeœniejsze instrukcje wywo³ywa³y b³¹d. Mo¿na sobie z nimi poradziæ korzystaj¹c z konstrukcji try/exept.

>>> try:
a = float(input('Enter a number: '))
except ValueError:
print('You entered an invalid number')

Aby przyj¹æ dane z klawiatury z wczeœniejszym komunikatem mo¿na u¿yæ konstrukcji:
a = input('Input an integer: ')

16.	Inny sposób na sprawdzanie typów

>>> 1.1.is_integer()
False

>>> 1.0.is_integer()
True

17.	U³amki i liczby zespolone jako dane wejœciowe

W tej wersji program zadzia³a:

>>> a = Fraction(input('Enter a fraction: '))
Enter a fraction: 3/4
>>> a
Fraction(3, 4)

A w tej?

>>> a = Fraction(input('Enter a fraction: '))
Enter a fraction: 3/0
Traceback (most recent call last):
File "<pyshell#2>", line 1, in <module>
a = Fraction(input('Enter a fraction: '))
File "/usr/lib64/python3.3/fractions.py", line 167, in __new__
raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
ZeroDivisionError: Fraction(3, 0)

W tym przypadku nasz program nie zadzia³a³. Mo¿emy go naprawiæ w nastêpuj¹cy sposób:

>>> try:
a = Fraction(input('Enter a fraction: '))
except ZeroDivisionError:
print('Invalid fraction')
Enter a fraction: 3/0
Invalid fraction

Podobnie w przypadku liczb zespolonych. Teraz program zadzia³a:

>>> z = complex(input('Enter a complex number: '))
Enter a complex number: 2+3j
>>> z
(2+3j)

Ale co jeœli wprowadzone dane bêd¹ w formie ³añcucha znaków '2 + 3j'?
Aby siê przed tym zabezpieczyæ warto skorzystaæ z wyj¹tku ValueError.

18.	Funkcje w³asne - zapoznaj siê z dzia³aniem poni¿szego kodu

Utwórzmy funkcjê, która bêdzie sprawdzaæ czy dana liczba jest jej dzielnikiem:

def is_factor(a, b):
if b % a == 0:
return True
else:
return False

A teraz j¹ wywo³ajmy:

>>> is_factor(4, 1024)
True

19.	Pêtla for

Aby wykonaæ pewn¹ czêœæ kodu wielokrotnie mo¿emy skorzystaæ z nastêpuj¹cej konstrukcji:

>>> for i in range(1, 4):
print(i)
1
2
3

Lub z takiej:

>>> for i in range(5):
print(i)
0
1
2
3
4


Lub z takiej:

>>> for i in range(1,10,2):
print(i)
1
3
5
7
9



20.	Formatowanie wyniku dzia³ania instrukcji print

Do wyœwietlanego komunikatu mo¿emy wprowadziæ zmienne za pomoc¹ operatora klamry i metody format. Przeanalizuj poni¿sze przyk³ady.

>>> item1 = 'apples'
>>> item2 = 'bananas'
>>> item3 = 'grapes'
>>> print('At the grocery store, I bought some {0} and {1} and {2}'.format(item1, item2, item3))
At the grocery store, I bought some apples and bananas and grapes


>>> print('Number 1: {0} Number 2: {1} '.format(1, 3.578))
Number 1: 1 Number 2: 3.578

Zadania:


1.	Napisz skrypt, który bêdzie wyœwietlaæ wszystkie kolejne dzielniki wprowadzonej liczby:
2.	Korzystaj¹c z pêtli for oraz mo¿liwoœci formatowania dzia³ania funkcji print utwórz program, który po prowadzeniu liczby wyœwietli nastêpuj¹cy komunikat:

Enter a number : 5 <- liczba wprowadzona przez uzytkownika
5.0 x 1 = 5.0
5.0 x 2 = 10.0
5.0 x 3 = 15.0
5.0 x 4 = 20.0
5.0 x 5 = 25.0
5.0 x 6 = 30.0
5.0 x 7 = 35.0
5.0 x 8 = 40.0
5.0 x 9 = 45.0
5.0	x 10 = 50.0

3.	Korzystaj¹c z pojêcia funkcji utwórz program, który bêdzie mia³ mo¿liwoœæ zamiany temperatury pomiêdzy skalami Celsjusza i Fahrenheita (w obie strony). C = (F-32)x(5/9), F = (C*9/5)+32
4.	Utwórz program do zamiany kilometrów na mile i na odwrót.
5.	Utwórz program do znajdowania miejsc zerowych trójmianu kwadratowego x1 = (-b+sqrt(b*b-4*a*c))/(2*a)
x2 = (-b-sqrt(b*b-4*a*c))/(2*a)
6.	Utwórz program, który bêdzie komunikowaæ, czy wprowadzona liczba jest dodatnia czy nie
7.	Utwórz program dodaj¹cy u³amki zwyk³e
8.	Utwórz program, który wy³¹czy siê po naciœniêciu przez u¿ytkownika konkretnego przycisku. 



